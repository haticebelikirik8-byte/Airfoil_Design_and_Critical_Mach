clc
clear
close all

% initial weight guess and bounds
u0 = [0.5, 0.4, 0.1, -0.5, -0.4, -.1];
lb =[0, 0, 0, -1, -1, -1];
ub =[1,1,1,0,0,0];
N =100;

objFun = @(u) M_critic(u, N);
nonlconFun = @(u) nonlcon(u, N);

options = optimoptions('fmincon', ...
    'Algorithm', 'sqp', ...
    'Display', 'iter', ...
    'ConstraintTolerance', 1e-5, ...
    'StepTolerance', 1e-12, ...
    'MaxIterations', 1000,...
    'MaxFunctionEvaluations', 10000);

[u_opt, fval , exitflag, output] = fmincon(objFun, u0, [], [], ...
    [], [], lb, ub, nonlconFun, options);

opt_coord = CST_airfoil(u_opt,N);
ylow = opt_coord(N/2+1:-1:1,2);
yup = opt_coord(N/2+1:1:end,2);

max_thickness = max(yup-ylow);

[~, Mach_critic,xmid,Cp] = M_critic(u_opt,N);
Cp_data = [xmid,Cp];

fprintf('Optimized Results:\n');
fprintf('Critical Mach Number: %.4f\n', Mach_critic);
fprintf('Maximum Thickness: %.4f\n', max_thickness);

save('CST_airfoil_coord.txt', 'opt_coord','-ascii');
save('CST_optim_val.txt','u_opt','-ascii');
save('CST_Critic_MACH.txt','Mach_critic','-ascii');
save('CST_cp.txt','Cp_data','-ascii');

% give constraint to create desired shape
function [c,ceq] = nonlcon(u,N)

coord = CST_airfoil(u,N);

ylow = coord(N/2+1:-1:1,2);
yup = coord(N/2+1:1:end,2);

c1 = 0.10-max(yup-ylow);
c = c1;
ceq = [];

end

% calculate Mach_critic
function [M, Mach_critic,xmid,Cp] = M_critic(u,N)

coord = CST_airfoil(u,N);

y = coord(:,2);
x = coord(:,1);

alpha = 0;
[xmid, Cp] = FindPandC(x, y, alpha * pi / 180);

Cp_min = min(Cp);
gamma = 1.4;

Mach_root = @(M) Cp_min / sqrt(1 - M^2) - 2 / (gamma * M^2) * ...
    (((1 + (gamma-1)/2 * M^2) / ((gamma+1)/2))^(gamma/(gamma-1)) - 1);

Mach_critic = fzero(Mach_root, 0.6);
M = -Mach_critic^2;

x_low = xmid(1:N/2);
Cp_low = Cp(1:N/2);
x_up = xmid(N/2:end);
Cp_up = Cp(N/2:end);

% plot cp distrubition and airfoil shape
persistent hFig hAirfoil hCp_up hCp_low
if isempty(hFig) || ~isvalid(hFig)
    hFig = figure('Name', 'Airfoil Optimization Progress', 'NumberTitle', 'off');
    
    subplot(2,1,1);
    hAirfoil = plot(x, y, 'b-', 'LineWidth', 2);
    axis equal
    grid on
    xlabel('x')
    ylabel('y')
    title('Airfoil Shape');
    
    subplot(2,1,2);
    hold on;
    hCp_up = plot(x_up, -Cp_up, 'bo-', 'LineWidth', 1.5); % Plot -Cp_up
    hCp_low = plot(x_low, -Cp_low, 'ro-', 'LineWidth', 1.5); % Plot -Cp_low
    grid on;
    xlabel('x (Chordwise Location)')
    ylabel('-C_p')
    title('Pressure Coefficient')
    legend('Upper Surface', 'Lower Surface', 'Location', 'best')
    axis tight
    
    drawnow
else
    set(hAirfoil, 'XData', x, 'YData', y);
    set(hCp_up, 'XData', x_up, 'YData', -Cp_up);
    set(hCp_low, 'XData', x_low, 'YData', -Cp_low);
    drawnow
end

end


function [coord] = CST_airfoil(w,N)
% Description: Create a set of airfoil coordinates using CST parametrization method
% Input:
%   wl = CST weight of lower surface
%   wu = CST weight of upper surface
%   dz = trailing edge thickness
%   N = number of points (excluding endpoints)
% Output:
%   coord = set of x-y coordinates of airfoil generated by CST

% Create x coordinates using cosine distribution

wu = w(1:3);
wl = w(4:6);
dz = 0;
x = ones(N+1, 1);
y = zeros(N+1, 1);
zeta = zeros(N+1, 1);
for i = 1:N+1
    zeta(i) = 2 * pi / N * (i-1);
    x(i) = 0.5 * (cos(zeta(i)) + 1);
end

% N1 and N2 parameters (N1 = 0.5 and N2 = 1 for airfoil shape)
N1 = 0.5;
N2 = 1;

% Find index where x = 0 to separate upper and lower surfaces
zerind = find(x(:, 1) == 0);
xl = x(1:zerind-1); % Lower surface x-coordinates
xu = x(zerind:end); % Upper surface x-coordinates

% Compute y-coordinates for lower and upper surfaces
yl = ClassShape(wl, xl, N1, N2, -dz); % Lower surface y-coordinates
yu = ClassShape(wu, xu, N1, N2, dz);  % Upper surface y-coordinates

% Combine upper and lower y coordinates
y = [yl; yu]; % Combine y coordinates
coord = [x y]; % Combine x and y into single output

% Nested function to calculate class and shape function
    function [y] = ClassShape(w, x, N1, N2, dz)
        % Class function: C(x) = x^N1 * (1-x)^N2
        C = zeros(size(x, 1), 1);
        for i = 1:size(x, 1)
            C(i, 1) = x(i)^N1 * ((1 - x(i))^N2);
        end
        
        % Shape function: Using Bernstein Polynomials
        n = size(w, 2) - 1; % Order of Bernstein polynomials
        K = zeros(1, n+1);
        for i = 1:n+1
            K(i) = factorial(n) / (factorial(i-1) * factorial(n - (i-1)));
        end
        
        S = zeros(size(x, 1), 1);
        for i = 1:size(x, 1)
            S(i, 1) = 0;
            for j = 1:n+1
                S(i, 1) = S(i, 1) + w(j) * K(j) * x(i)^(j-1) * ((1 - x(i))^(n - (j-1)));
            end
        end
        
        % Calculate y output: y = C * S + x * dz
        y = zeros(size(x, 1), 1);
        for i = 1:size(x, 1)
            y(i, 1) = C(i, 1) * S(i, 1) + x(i) * dz;
        end
    end
end

function [xmid,Cp]=FindPandC(x,y,alpha)
%This function finds a coefficient matrix using the information
%given by the x and y coordinates of the body shape., and finds
%the solution matrix.  It then uses that to find the pressures
%along the surface and the lift,moment,drag coefficients.
%Input  x     - x values of contour
%       y     - y values of contour
%       alpha - angle of attack
%Output sol   - solution to A*sol=b

%Initializingw
nodetotal=length(x);
A=zeros(nodetotal);
b=zeros(nodetotal,1);
c=A;

dx=x(2:nodetotal)-x(1:nodetotal-1);
dy=y(2:nodetotal)-y(1:nodetotal-1);
sintheta=dy./sqrt(dx.*dx+dy.*dy);
costheta=dx./sqrt(dx.*dx+dy.*dy);
xmid=(x(1:nodetotal-1)+x(2:nodetotal))/2;
ymid=(y(1:nodetotal-1)+y(2:nodetotal))/2;

dxj=xmid-x(1:nodetotal-1);
dxjp=xmid-x(2:nodetotal);
dyj=ymid-y(1:nodetotal-1);
dyjp=ymid-y(2:nodetotal);
flog=.5*log((dxjp.*dxjp+dyjp.*dyjp)./(dxj.*dxj+dyj.*dyj));
ftan=atan2(dyjp.*dxj-dxjp.*dyj,dxjp.*dxj+dyjp.*dyj);

%Create A matrix
for i=1:nodetotal-1
    for j=1:nodetotal-1
        flog=0;
        ftan=pi;
        if j~=i
            dxj=xmid(i)-x(j);
            dxjp=xmid(i)-x(j+1);
            dyj=ymid(i)-y(j);
            dyjp=ymid(i)-y(j+1);
            flog=.5*log((dxjp*dxjp+dyjp*dyjp)/(dxj*dxj+dyj*dyj));
            ftan=atan2(dyjp*dxj-dxjp*dyj,dxjp*dxj+dyjp*dyj);
        end
        ctimtj=costheta(i)*costheta(j)+sintheta(i)*sintheta(j);
        stimtj=sintheta(i)*costheta(j)-sintheta(j)*costheta(i);
        A(i,j)=(.5/pi)*(ftan*ctimtj+flog*stimtj);
        c(i,j)=(.5/pi)*(flog*ctimtj-ftan*stimtj);
        A(i,nodetotal)=A(i,nodetotal)+c(i,j);
        if i==1 || i==nodetotal-1
            %If ith panel touches trailing edge, add contribution
            %to kutta condition
            A(nodetotal,j)=A(nodetotal,j)-c(i,j);
            A(nodetotal,nodetotal)=A(nodetotal,nodetotal)+A(i,j);
        end
    end
    %Fill in known sides
    b(i)=sintheta(i)*cos(alpha)-costheta(i)*sin(alpha);
end
b(nodetotal)=-(costheta(1)+costheta(nodetotal-1))*cos(alpha)-(sintheta(1)+sintheta(nodetotal-1))*sin(alpha);
sol=A\b;

%Use solution to find Pressures along airfoil
Cp=zeros(nodetotal-1,1);
for i=1:nodetotal-1
    vtang=cos(alpha)*costheta(i)+sin(alpha)*sintheta(i);
    for j=1:nodetotal-1
        vtang=vtang-c(i,j)*sol(j)+sol(nodetotal)*A(i,j);
    end
    Cp(i)=1-vtang^2;
end

end

\end{lstlisting}

\subsection{Polynomial Airfoil Optimization Code}
\lstset{
    language=Matlab,
    backgroundcolor=\color{lightgray!10}, % arka plan r
}


\lstset{language=Matlab}
\begin{lstlisting}
clear
clc
close all

% initial guess and bounds 
u0 = [0.1, 0.3, -0.1, -0.3];
lb =[0, 0, -1, -1];
ub =[1,1,0,0];

options = optimoptions('fmincon', ...
    'Algorithm', 'sqp', ...
    'Display', 'iter', ...
    'ConstraintTolerance', 1e-5, ...
    'StepTolerance', 1e-10, ...
    'MaxIterations', 1000,...
    'MaxFunctionEvaluations', 10000);

[u_opt, fval_local, exitflag, output] = fmincon(@M_critic, u0, [], [], [], [], lb, ub, @nonlcon, options);

alphaxx = linspace(0,pi, 51);
xx = (1-cos(alphaxx))/2;

% lower surface y_low
ylow = u_opt(1)*xx.^3  + u_opt(2)*xx.^2 -(u_opt(1)+u_opt(2))*xx;
% upper surface y_up
yup = u_opt(3)*xx.^3  + u_opt(4)*xx.^2 - (u_opt(3)+u_opt(4))*xx;

max_thickness = max(yup - ylow);
y = [ylow(end:-1:1), yup(2:end)];
x = [xx(end:-1:1),xx(2:end )];
airfoil=[x;y]';

[~, Mach_critic,xmid, Cp] = M_critic(u_opt);
Cp_data = [xmid;Cp']';

fprintf('Optimized Results:\n');
fprintf('Critical Mach Number: %.4f\n', Mach_critic);
fprintf('Maximum Thickness: %.4f\n', max_thickness);

save('POL_cord.txt', 'airfoil' ,'-ascii');
save('POL_opt.txt','u_opt','-ascii');
save('POL_Mach_citic.txt','Mach_critic','-ascii');
save('POL_cp.txt','Cp_data','-ascii');

% constraints 
function [c, ceq] = nonlcon(u)

alphaxx = linspace(0,pi, 51);
xx = (1-cos(alphaxx))/2;
ylow = u(1)*xx.^3 +u(2)*xx.^2 - (u(1)+u(2))*xx;
yup = u(3)*xx.^3 + u(4)*xx.^2 - (u(3)+u(4))*xx;

c1 = 0.10 - max(yup-ylow);  %min max thickness 10%
c2 =  1e-5 - min(yup-ylow);  % to avoid absurd shape, give min thickness
c = [c1,c2];
ceq = [];
end

function [M, Mach_critic,xmid, Cp] = M_critic(u)

alphaxx = linspace(0,pi, 51);
xx = (1-cos(alphaxx))/2;
ylow = u(1)*xx.^3 +u(2)*xx.^2 -(u(1)+u(2))*xx;
yup = u(3)*xx.^3 + u(4)*xx.^2 - (u(3)+u(4))*xx;

y = [ylow(end:-1:1), yup(2:end)];
x = [xx(end:-1:1), xx(2:end )];

mnx = min(x); mxx = max(x);
chord = mxx - mnx;
x = (x - mnx) / chord;
y = y/ chord;

alpha = 0;
[xmid, Cp] = FindPandC(x, y, alpha * pi / 180);

Cp_min = min(Cp);
gamma = 1.4;

Mach_root = @(M) Cp_min / sqrt(1 - M^2) - 2 / (gamma * M^2) * ...
    (((1 + (gamma-1)/2 * M^2) / ((gamma+1)/2))^(gamma/(gamma-1)) - 1);

Mach_critic = fzero(Mach_root, 0.6);  % find Mach_critic for a given shape
M = -Mach_critic^2;

x_low = xmid(1:50);
Cp_low = Cp(1:50);
x_up = xmid(50:end);
Cp_up = Cp(50:end);

% visiualize the shape and cp distrubition
persistent hFig1 hFig2 hAirfoil hCp_up hCp_low
if isempty(hFig1) || ~isvalid(hFig1)
    hFig1 = figure('Name', 'Airfoil Shape', 'NumberTitle', 'off');
    
    hAirfoil = plot(x, y, 'b-', 'LineWidth', 2);
    axis equal
    grid on
    xlabel('x')
    ylabel('y')
    title('Airfoil Shape');
elseif  isempty(hFig2) || ~isvalid(hFig2)
    hFig2 = figure('Name', 'Cp Distrubiton', 'NumberTitle', 'off');
    hold on;
    hCp_up = plot(x_up, -Cp_up, 'bo-', 'LineWidth', 1.5); % Plot -Cp_up
    hCp_low = plot(x_low, -Cp_low, 'ro-', 'LineWidth', 1.5); % Plot -Cp_low
    grid on;
    xlabel('x (Chordwise Location)')
    ylabel('-C_p')
    title('Pressure Coefficient')
    legend('Upper Surface', 'Lower Surface', 'Location', 'best')
    
    drawnow
else
    
    set(hAirfoil, 'XData', x, 'YData', y);
    set(hCp_up, 'XData', x_up, 'YData', -Cp_up);
    set(hCp_low, 'XData', x_low, 'YData', -Cp_low);
    drawnow
end

end

function [xmid,Cp]=FindPandC(x,y,alpha)
%This function finds a coefficient matrix using the information
%given by the x and y coordinates of the body shape., and finds
%the solution matrix.  It then uses that to find the pressures
%along the surface and the lift,moment,drag coefficients.
%Input  x     - x values of contour
%       y     - y values of contour
%       alpha - angle of attack
%Output sol   - solution to A*sol=b

%Initializingw
nodetotal=length(x);
A=zeros(nodetotal);
b=zeros(nodetotal,1);
c=A;

dx=x(2:nodetotal)-x(1:nodetotal-1);
dy=y(2:nodetotal)-y(1:nodetotal-1);
sintheta=dy./sqrt(dx.*dx+dy.*dy);
costheta=dx./sqrt(dx.*dx+dy.*dy);
xmid=(x(1:nodetotal-1)+x(2:nodetotal))/2;
ymid=(y(1:nodetotal-1)+y(2:nodetotal))/2;

dxj=xmid-x(1:nodetotal-1);
dxjp=xmid-x(2:nodetotal);
dyj=ymid-y(1:nodetotal-1);
dyjp=ymid-y(2:nodetotal);
flog=.5*log((dxjp.*dxjp+dyjp.*dyjp)./(dxj.*dxj+dyj.*dyj));
ftan=atan2(dyjp.*dxj-dxjp.*dyj,dxjp.*dxj+dyjp.*dyj);

%Create A matrix
for i=1:nodetotal-1
    for j=1:nodetotal-1
        flog=0;
        ftan=pi;
        if j~=i
            dxj=xmid(i)-x(j);
            dxjp=xmid(i)-x(j+1);
            dyj=ymid(i)-y(j);
            dyjp=ymid(i)-y(j+1);
            flog=.5*log((dxjp*dxjp+dyjp*dyjp)/(dxj*dxj+dyj*dyj));
            ftan=atan2(dyjp*dxj-dxjp*dyj,dxjp*dxj+dyjp*dyj);
        end
        ctimtj=costheta(i)*costheta(j)+sintheta(i)*sintheta(j);
        stimtj=sintheta(i)*costheta(j)-sintheta(j)*costheta(i);
        A(i,j)=(.5/pi)*(ftan*ctimtj+flog*stimtj);
        c(i,j)=(.5/pi)*(flog*ctimtj-ftan*stimtj);
        A(i,nodetotal)=A(i,nodetotal)+c(i,j);
        if i==1 || i==nodetotal-1
            %If ith panel touches trailing edge, add contribution
            %to kutta condition
            A(nodetotal,j)=A(nodetotal,j)-c(i,j);
            A(nodetotal,nodetotal)=A(nodetotal,nodetotal)+A(i,j);
        end
    end
    %Fill in known sides
    b(i)=sintheta(i)*cos(alpha)-costheta(i)*sin(alpha);
end
b(nodetotal)=-(costheta(1)+costheta(nodetotal-1))*cos(alpha)-(sintheta(1)+sintheta(nodetotal-1))*sin(alpha);
sol=A\b;

%Use solution to find Pressures along airfoil
Cp=zeros(nodetotal-1,1);
for i=1:nodetotal-1
    vtang=cos(alpha)*costheta(i)+sin(alpha)*sintheta(i);
    for j=1:nodetotal-1
        vtang=vtang-c(i,j)*sol(j)+sol(nodetotal)*A(i,j);
    end
    Cp(i)=1-vtang^2;
end

end


\end{lstlisting}


 \subsection{Spline Airfoil Optimization Code}
\lstset{
    language=Matlab,
    backgroundcolor=\color{lightgray!10}, % arka plan r
}


\lstset{language=Matlab}
\begin{lstlisting}
clear
clc
close all

% initial guess and bounds 
u0 = [0.07 -0.07 0.3,-0.05,-0.3, 0.05];
lb =[0, -1, 0, -1, -1, 0];
ub =[1, 0, 1, 0, 0, 1];

options = optimoptions('fmincon', ...
    'Algorithm', 'sqp', ...
    'Display', 'iter', ...
    'ConstraintTolerance', 1e-5, ...
    'StepTolerance', 1e-10, ...
    'MaxIterations', 1000,...
    'MaxFunctionEvaluations', 10000);
[u_opt, fval, exitflag, output] = fmincon(@M_critic, u0, [], [], [], [], lb, ub, @nonlcon, options);

alphaxx = linspace(0,pi, 51);
xx = (1-cos(alphaxx))/2;
xxs = [0 1/3 1];
csup = spline(xxs, [u_opt(3) [0 u_opt(1) 0] u_opt(4)]);
cslow = spline(xxs,[u_opt(5) [0 u_opt(2) 0] u_opt(6)]);
yup = ppval(csup, xx);
ylow = ppval(cslow, xx);

max_thickness = max(yup - ylow);
y = [ylow(end:-1:1), yup(2:end)];
x = [xx(end:-1:1), xx(2:end )];
airfoil=[x;y]';

[~, Mach_critic,xmid, Cp] = M_critic(u_opt);
Cp_data = [xmid;Cp']';

fprintf('Optimized Results:\n');
fprintf('Critical Mach Number: %.4f\n', Mach_critic);
fprintf('Maximum Thickness: %.4f\n', max_thickness);

save('SP_cord.txt', 'airfoil' ,'-ascii');
save('SP_opt.txt','u_opt','-ascii');
save('SP_Mach_citic.txt','Mach_critic','-ascii');
save('SP_cp.txt','Cp_data','-ascii');

% constraints are given below
function [c, ceq] = nonlcon(u)

xxs = [0 1/3 1];
alphaxx = linspace(0,pi,51);
xx = (1-cos(alphaxx))/2;
csup = spline(xxs,[u(3) [0 u(1) 0] u(4)]);
cslow = spline(xxs,[u(5) [0 u(2) 0] u(6)]);
yup = ppval(csup,xx);
ylow = ppval(cslow,xx);

c1 = 0.10 - max(yup-ylow);  %minimum thickness should be greater than 10%
c2 = 1e-5-min(yup-ylow);     % to avoid complex shape give a min thhickness
c = [c1,c2];
ceq = [];

% to give desired slop at specific location shape use below commented code

% dcup = fnder(csup);
% dy_dx_u = ppval(dcup,0.3);
% dclow = fnder(cslow);
% dy_dx_l = ppval(dclow,0.3);
% ceq = [dy_dx_u,dy_dx_l];

end

function [M, Mach_critic,xmid, Cp] = M_critic(u)
xxs = [0 1/3 1];
csup = spline(xxs,[u(3) [0 u(1) 0] u(4)]);
cslow = spline(xxs,[u(5) [0 u(2) 0] u(6)]);

% to catch the leading edge and trailing edge use cosine distrubition
alphaxx = linspace(0,pi, 51);
xx = (1-cos(alphaxx))/2;

yup = ppval(csup,xx);
ylow = ppval(cslow,xx);
y = [ylow(end:-1:1), yup(2:end)];
x = [xx(end:-1:1), xx(2:end )];

%calculate cp using panel method
alpha = 0;
[xmid, Cp] = FindPandC(x, y, alpha * pi / 180);

%find Mach critic
Cp_min = min(Cp);
gamma = 1.4;

Mach_root = @(M) Cp_min / sqrt(1 - M^2) - 2 / (gamma * M^2) * ...
    (((1 + (gamma-1)/2 * M^2) / ((gamma+1)/2))^(gamma/(gamma-1)) - 1);

Mach_critic = fzero(Mach_root, 0.5);
M = -Mach_critic^2;

% plot the cp distrubition and airfoil shape
x_low = xmid(1:50);
Cp_low = Cp(1:50);
x_up = xmid(50:end);
Cp_up = Cp(50:end);

persistent hFig hAirfoil hCp_up hCp_low
if isempty(hFig) || ~isvalid(hFig)
    hFig = figure('Name', 'Airfoil Optimization Progress', 'NumberTitle', 'off');
    
    subplot(2,1,1);
    hAirfoil = plot(x, y, 'b-', 'LineWidth', 2);
    axis equal
    grid on
    xlabel('x')
    ylabel('y')
    title('Airfoil Shape');
    
    subplot(2,1,2);
    hold on;
    hCp_up = plot(x_up, -Cp_up, 'bo-', 'LineWidth', 1.5); % Plot -Cp_up
    hCp_low = plot(x_low, -Cp_low, 'ro-', 'LineWidth', 1.5); % Plot -Cp_low
    grid on;
    xlabel('x (Chordwise Location)')
    ylabel('-C_p')
    title('Pressure Coefficient')
    legend('Upper Surface', 'Lower Surface', 'Location', 'best')
    axis tight
    
    drawnow
else
    % Update plots
    set(hAirfoil, 'XData', x, 'YData', y);
    set(hCp_up, 'XData', x_up, 'YData', -Cp_up); % Update -Cp_up
    set(hCp_low, 'XData', x_low, 'YData', -Cp_low); % Update -Cp_low
    drawnow
end

end


function [xmid,Cp]=FindPandC(x,y,alpha)
%This function finds a coefficient matrix using the information
%given by the x and y coordinates of the body shape., and finds
%the solution matrix.  It then uses that to find the pressures
%along the surface and the lift,moment,drag coefficients.
%Input  x     - x values of contour
%       y     - y values of contour
%       alpha - angle of attack
%Output sol   - solution to A*sol=b

%Initializingw
nodetotal=length(x);
A=zeros(nodetotal);
b=zeros(nodetotal,1);
c=A;

dx=x(2:nodetotal)-x(1:nodetotal-1);
dy=y(2:nodetotal)-y(1:nodetotal-1);
sintheta=dy./sqrt(dx.*dx+dy.*dy);
costheta=dx./sqrt(dx.*dx+dy.*dy);
xmid=(x(1:nodetotal-1)+x(2:nodetotal))/2;
ymid=(y(1:nodetotal-1)+y(2:nodetotal))/2;

dxj=xmid-x(1:nodetotal-1);
dxjp=xmid-x(2:nodetotal);
dyj=ymid-y(1:nodetotal-1);
dyjp=ymid-y(2:nodetotal);
flog=.5*log((dxjp.*dxjp+dyjp.*dyjp)./(dxj.*dxj+dyj.*dyj));
ftan=atan2(dyjp.*dxj-dxjp.*dyj,dxjp.*dxj+dyjp.*dyj);

%Create A matrix
for i=1:nodetotal-1
    for j=1:nodetotal-1
        flog=0;
        ftan=pi;
        if j~=i
            dxj=xmid(i)-x(j);
            dxjp=xmid(i)-x(j+1);
            dyj=ymid(i)-y(j);
            dyjp=ymid(i)-y(j+1);
            flog=.5*log((dxjp*dxjp+dyjp*dyjp)/(dxj*dxj+dyj*dyj));
            ftan=atan2(dyjp*dxj-dxjp*dyj,dxjp*dxj+dyjp*dyj);
        end
        ctimtj=costheta(i)*costheta(j)+sintheta(i)*sintheta(j);
        stimtj=sintheta(i)*costheta(j)-sintheta(j)*costheta(i);
        A(i,j)=(.5/pi)*(ftan*ctimtj+flog*stimtj);
        c(i,j)=(.5/pi)*(flog*ctimtj-ftan*stimtj);
        A(i,nodetotal)=A(i,nodetotal)+c(i,j);
        if i==1 || i==nodetotal-1
            %If ith panel touches trailing edge, add contribution
            %to kutta condition
            A(nodetotal,j)=A(nodetotal,j)-c(i,j);
            A(nodetotal,nodetotal)=A(nodetotal,nodetotal)+A(i,j);
        end
    end
    %Fill in known sides
    b(i)=sintheta(i)*cos(alpha)-costheta(i)*sin(alpha);
end
b(nodetotal)=-(costheta(1)+costheta(nodetotal-1))*cos(alpha)-(sintheta(1)+sintheta(nodetotal-1))*sin(alpha);
sol=A\b;

%Use solution to find Pressures along airfoil
Cp=zeros(nodetotal-1,1);
for i=1:nodetotal-1
    vtang=cos(alpha)*costheta(i)+sin(alpha)*sintheta(i);
    for j=1:nodetotal-1
        vtang=vtang-c(i,j)*sol(j)+sol(nodetotal)*A(i,j);
    end
    Cp(i)=1-vtang^2;
end

end
